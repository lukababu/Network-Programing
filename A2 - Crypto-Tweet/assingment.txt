Your primary task in this assignment is to build a network-based application that offers tweet encoding (and decoding) as a service to users. For example, T-Rump could send his most recent thoughts to the server, and receive the appropriate encoding for his tweets before posting them on Twitter. Conversely, a tech-savvy follower could use the same server to decode each tweet.

There are lots of design decisions for you in this assignment. One decision will be deciding between UDP (fast but unreliable data transfer) and TCP (slow but reliable data transfer) as your transport-layer protocol. Related to this will be the decision about whether the server handles a word at a time (i.e., transaction-oriented) or a full sentence at a time (i.e., session-oriented). Another decision will be how to distinguish an encoding request from a decoding request. The implicit suggestion above is to use the leading "0x" (the ASCII character 'zero' followed by the letter 'x') as a way to tell these two cases apart, since no regular English words start with "0x", but you could have separate application-layer commands for these operations, if you so wish. Yet another decision will be regarding what protocol state information (if any) is kept at either the client side or the server side (or both). See below for further information about this issue. Last but not least, you will have to think about how some error conditions are handled. For example, what happens if a packet gets lost, or the server does not respond? What happens if multiple words have the same encoding? And what happens if you try to decode a hash value that does not exist in the server's database? Make sure to put your thinking caps on, and make good choices on these decisions!

A secondary task for you will be to come up with a suitable word hashing scheme. You will need this hashing scheme to be simple and efficient, yet capable of providing deterministic, consistent, and correct results (i.e., idempotent operation). That is, you want a one-to-one mapping between words and their hashes, so that there are no confusions in the translations during either encoding or decoding.

You are required to implement three different hashing schemes:

The first hashing scheme is called Sequential Index. In this simple scheme, the server incrementally builds its lexicon from the observed words, and assigns the next integer value to each new word seen. For example, the classic poem "Mary had a little lamb; A little pork, a little ham; Mary had a little lamb; And then she had dessert." might be encoded as "0x1 0x2 0x3 0x4 0x5; 0x6 0x4 0x7, 0x3 0x4 0x8; 0x1 0x2 0x3 0x4 0x5; 0x9 0xa 0xb 0x2 0xc." Note that punctuation marks remain as is; there is no need to encode or decode them. This scheme is simple and intuitive, but has several drawbacks. For instance, the encodings will get larger and larger over time as the server builds up its database of words. Furthermore, all state information is lost each time the server is restarted, so decoding past tweets will be problematic.
The second hashing scheme is called Word Sum. In this scheme, the hashes are a fixed size, and are constructed by summing the ASCII values of the characters in a word. For example, "Mary had a little lamb" would become "0x0199 0x012d 0x0061 0x028e 0x019c" if a 16-bit sum is used. This hash is idempotent, and requires minimal server state information, but may not provide unique translations. For example, the words "great" and "grate" would both end up being encoded as 0x0213.
The third hashing scheme is called Your Hash. It is a scheme of your own design, which is (hopefully) superior to the two simple schemes described above. You should give some careful thought to this design, and then implement it correctly, and explain it clearly in your documentation, stating both its strengths and weaknesses. If you need some inspiration, you could look at the specifications for the "Internet checksum", MD5 hashes, DES, Rabin fingerprints, and blockchain technologies. There will be no lack of creative ideas here, but you need to find something that is implementable and repeatable.